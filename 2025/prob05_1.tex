\newlinechar=`\^^J
\message{^^J^^J}

\newread\file
\openin\file=data05.txt

\def\ranges{}
\def\newrange#1#2{
  \edef\ranges{\ranges,#1+#2}
}
\def\split#1-#2{\newrange{#1}{#2}}
\def\mysplit#1{\expandafter\split#1\relax}

\message{Parsing fresh ranges...^^J}

% Negative version of loop to read lines from a file.  Made it "long"
% to allow \par in the conditional so we don't need to hide that in a
% separate macro. (Is it really this hard?)
\long\def\nloop#1\repeat{\def\body{#1}\niterate}
\def\niterate{\body \let\next=\relax \else\let\next=\niterate\fi \next}
\let\repeat=\fi % this makes \loop...\if...\repeat skippable

% read to blank line
\def\ifisnum#1{\ifcat1#1}
\nloop
  \read\file to\fileline
  \ifisnum\fileline\mysplit\fileline\fi
  \ifcat\par\fileline % if the line is blank
\repeat

\message{Got these: \ranges^^J}
\message{Parsing available ingredients...^^J}

% read to end
\nloop
  \read\file to\num
  \ifisnum\num
    \message{\num}
    \ifnum\num<3\message{true}\fi
  \fi
  \ifeof\file
\repeat

\closein\file


\message{^^J^^J}

\end
